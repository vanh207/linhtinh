<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Heart Fixed Rotation</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        #video-bg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 1.0; z-index: 0; }
        #c { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }
        #info { position: absolute; top: 20px; left: 20px; z-index: 10; color: #fff; background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(8px); border: 1px solid rgba(255, 255, 255, 0.2); padding: 15px; border-radius: 12px; width: 260px; pointer-events: auto; user-select: none; }
        h3 { margin: 0 0 10px 0; color: #ff3366; text-transform: uppercase; font-size: 16px; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 10px;}
        #log { font-weight: bold; color: #f6e05e; text-align: center; margin-bottom: 10px; font-size: 13px;}
        .row { display: flex; align-items: center; margin-bottom: 5px; font-size: 13px; color: #eee; }
        .icon { width: 25px; text-align: center; margin-right: 8px; font-size: 18px;}
        .highlight { color: #00ffcc; font-weight: bold; margin-right: 5px;}
        .section { margin-top: 10px; margin-bottom: 5px; color: #aaa; font-size: 11px; font-weight: bold; text-transform: uppercase; letter-spacing: 1px;}
    </style>
</head>
<body>
    <video id="video-bg" playsinline webkit-playsinline></video>
    <canvas id="c"></canvas>
    <div id="info">
        <h3>AR Magic Effects</h3>
        <div id="log">‚è≥ ƒêang ƒë·ª£i Camera...</div>
        <div class="section">üëâ Tay Ph·∫£i (H√¨nh D√°ng)</div>
        <div class="row"><span class="icon">‚òùÔ∏è</span>1: Xo·∫Øn ·ªëc</div>
        <div class="row"><span class="icon">‚úåÔ∏è</span>2: <b style="color:#ff3366">TR√ÅI TIM (ƒê·ª©ng y√™n)</b></div>
        <div class="row"><span class="icon">ü§ü</span>3: Nguy√™n T·ª≠</div>
        <div class="row"><span class="icon">üññ</span>4: <b style="color:#00BFFF">B√ÅNH DONUT üç©</b></div>
        <div class="row"><span class="icon">üñêÔ∏è</span>5: H√¨nh C·∫ßu</div>
        <div class="section">üëà Tay Tr√°i (T∆∞∆°ng T√°c)</div>
        <div class="row"><span class="icon">ü§è</span><span class="highlight">Ch·ª•m:</span> H√∫t</div>
        <div class="row"><span class="icon">‚úä</span><span class="highlight">N·∫Øm:</span> ƒê√≥ng bƒÉng</div>
        <div class="row"><span class="icon">‚òùÔ∏è</span><span class="highlight">Ch·ªâ:</span> ƒê·∫©y</div>
        <div class="row"><span class="icon">üñêÔ∏è</span><span class="highlight">M·ªü:</span> N·ªï</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        const P_COUNT = 7000;
        const TOUCH_DIST_SQ = 60 * 60;
        
        // C·∫•u h√¨nh Tim ƒê·∫≠p
        const HEART_FORM_STRENGTH = 0.1;
        const HEART_BEAT_INTENSITY = 0.15;
        
        let scene, camera, renderer, particles;
        let positionsCurrent = [], velocities = [], colorsBuffer = [], sizes = [];
        let posArr, colArr;
        const clock = new THREE.Clock();
        
        const targets = { chaos:[], spiral:[], heartBase:[], atom:[], torus:[], sphere:[] };
        let activeTarget = targets.sphere;
        let activeTargetName = 'sphere'; 

        let leftHandAction = 'none';
        let interactionPoint = new THREE.Vector3();

        const video = document.getElementById('video-bg');
        const log = document.getElementById('log');
        
        let baseColor = new THREE.Color(0x00ffcc); 
        const heartColor = new THREE.Color(0xff3366);
        const torusColor = new THREE.Color(0x00BFFF); 
        let tempColor = new THREE.Color();
        let wasMoving = false;

        async function setup() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 }, audio: false });
                video.srcObject = stream;
                await new Promise(r => video.onloadedmetadata = () => { video.play(); r(); });
                const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                hands.onResults(onAIResults);
                init3D();
                const sendFrame = async () => { if (video.readyState >= 2) await hands.send({image: video}); requestAnimationFrame(sendFrame); };
                sendFrame();
            } catch (e) { log.innerText = "‚ùå L·ªói Camera: " + e.message; log.style.color = "red"; }
        }

        function init3D() {
            const canvas = document.getElementById('c');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 3000);
            camera.position.z = 650;
            renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            calcShapes(); createParticles(); animate();
            log.innerText = "‚úÖ OK! H·ªá th·ªëng s·∫µn s√†ng."; log.style.color = "#00ff00";
        }

        function createParticles() {
            const geo = new THREE.BufferGeometry();
            for(let i=0; i<P_COUNT; i++) {
                positionsCurrent.push(0,0,0); velocities.push(0,0,0);
                sizes.push(Math.random()*8 + 4); colorsBuffer.push(baseColor.r, baseColor.g, baseColor.b);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positionsCurrent, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colorsBuffer, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            posArr = geo.attributes.position.array; colArr = geo.attributes.color.array;
            const tex = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png');
            const mat = new THREE.PointsMaterial({ size: 11, vertexColors: true, map: tex, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.85 });
            particles = new THREE.Points(geo, mat); scene.add(particles);
        }

        function calcShapes() {
            for(let i=0; i<P_COUNT; i++) {
                // Sphere
                const phi = Math.acos(-1+(2*i)/P_COUNT), theta = Math.sqrt(P_COUNT*Math.PI)*phi;
                targets.sphere.push(220*Math.cos(theta)*Math.sin(phi), 220*Math.sin(theta)*Math.sin(phi), 220*Math.cos(phi));
                
                // Atom
                const ang=(i/P_COUNT)*Math.PI*2*3, r=200, s=i%3;
                if(s==0) targets.atom.push(r*Math.cos(ang), r*Math.sin(ang), 0); else if(s==1) targets.atom.push(r*Math.cos(ang), 0, r*Math.sin(ang)); else targets.atom.push(0, r*Math.cos(ang), r*Math.sin(ang));
                
                // Spiral
                const t2=i*0.06, r2=10+i*0.05; targets.spiral.push(r2*Math.cos(t2), (i*0.1)-300, r2*Math.sin(t2));

                // Torus
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI * 2;
                const R_torus = 250; 
                const r_torus = 80;  
                const x = (R_torus + r_torus * Math.cos(v)) * Math.cos(u);
                const y = r_torus * Math.sin(v);
                const z = (R_torus + r_torus * Math.cos(v)) * Math.sin(u);
                targets.torus.push(x, y, z);
            }

            // TR√ÅI TIM R·ªñNG (Shell)
            for(let i=0; i<P_COUNT; i++) {
                const t = Math.random() * Math.PI * 2;
                let hx = 16 * Math.pow(Math.sin(t), 3);
                let hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                
                const rSpread = 0.8 + Math.random() * 0.4;
                hx *= rSpread; hy *= rSpread;
                const hz = (Math.random() - 0.5) * 40; 

                const scale = 13;
                targets.heartBase.push(hx * scale, hy * scale + 40, hz);
            }
        }

        function countFingers(lm) {
            let c=0; if(lm[8].y<lm[6].y) c++; if(lm[12].y<lm[10].y) c++; if(lm[16].y<lm[14].y) c++; if(lm[20].y<lm[18].y) c++; return c;
        }
        function get3DPoint(lmIndex) {
             const ndcX = (1 - lmIndex.x) * 2 - 1; const ndcY = -(lmIndex.y * 2 - 1);
             return new THREE.Vector3(ndcX, ndcY, 0.5).unproject(camera).sub(camera.position).normalize().multiplyScalar(600).add(camera.position);
        }

        function onAIResults(results) {
            leftHandAction = 'none'; if (!results.multiHandLandmarks) return;
            for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                const lm = results.multiHandLandmarks[i]; const label = results.multiHandedness[i].label;
                let fingers = countFingers(lm); if (label==='Left' ? lm[4].x>lm[3].x : lm[4].x<lm[3].x) fingers++;
                if (label === 'Left') {
                    if(fingers<=1 && lm[8].y<lm[6].y && lm[12].y>lm[10].y) fingers=1;
                    switch(fingers) {
                        case 1: activeTarget = targets.spiral; activeTargetName = 'spiral'; break;
                        case 2: activeTarget = targets.heartBase; activeTargetName = 'heart'; break;
                        case 3: activeTarget = targets.atom; activeTargetName = 'atom'; break;
                        case 4: activeTarget = targets.torus; activeTargetName = 'torus'; break;
                        default: activeTarget = targets.sphere; activeTargetName = 'sphere'; break;
                    }
                } else if (label === 'Right') {
                    const pinchDist = Math.sqrt(Math.pow(lm[4].x-lm[8].x,2) + Math.pow(lm[4].y-lm[8].y,2));
                    if (fingers === 0) leftHandAction = 'freeze'; else if (pinchDist < 0.05) { leftHandAction = 'pinch'; interactionPoint = get3DPoint({x: (lm[4].x+lm[8].x)/2, y: (lm[4].y+lm[8].y)/2}); } else if (fingers >= 4) leftHandAction = 'explode'; else if (fingers === 1) { leftHandAction = 'touch'; interactionPoint = get3DPoint(lm[8]); }
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.0008; const clockTime = clock.getElapsedTime();
            
            // Nh·ªãp tim
            const beatScale = 1 + Math.pow(Math.sin(clockTime * 4), 6) * HEART_BEAT_INTENSITY;
            
            const isPhysicsMode = leftHandAction !== 'none' && leftHandAction !== 'freeze';
            let totalSpeedSq = 0;

            for(let i=0; i<P_COUNT; i++) {
                const i3 = i*3; let px = positionsCurrent[i3], py = positionsCurrent[i3+1], pz = positionsCurrent[i3+2]; let vx = velocities[i3], vy = velocities[i3+1], vz = velocities[i3+2];

                if (leftHandAction === 'freeze') { vx *= 0.1; vy *= 0.1; vz *= 0.1; } 
                else if (leftHandAction === 'explode') { vx += (Math.random()-0.5)*15; vy += (Math.random()-0.5)*15; vz += (Math.random()-0.5)*15; }
                else if (leftHandAction === 'pinch') {
                    const dx = px - interactionPoint.x; const dy = py - interactionPoint.y; const dz = pz - interactionPoint.z; const distSq = dx*dx + dy*dy + dz*dz + 10; const force = -3500 / distSq; vx += dx * force * 0.05; vy += dy * force * 0.05; vz += dz * force * 0.05;
                }
                else if (leftHandAction === 'touch') {
                    const dx = px - interactionPoint.x; const dy = py - interactionPoint.y; const dz = pz - interactionPoint.z; const distSq = dx*dx + dy*dy + dz*dz; if (distSq < TOUCH_DIST_SQ) { const force = (TOUCH_DIST_SQ - distSq) / TOUCH_DIST_SQ; vx += dx*force*2.2; vy += dy*force*2.2; vz += dz*force*2.2; }
                }
                
                else if (activeTargetName === 'heart') {
                    const tx = targets.heartBase[i3] * beatScale; 
                    const ty = targets.heartBase[i3+1] * beatScale; 
                    const tz = targets.heartBase[i3+2] * beatScale;
                    
                    vx += (tx - px) * HEART_FORM_STRENGTH; 
                    vy += (ty - py) * HEART_FORM_STRENGTH; 
                    vz += (tz - pz) * HEART_FORM_STRENGTH;
                    vx *= 0.85; vy *= 0.85; vz *= 0.85;
                }
                
                else {
                    const tx = activeTarget[i3]||0, ty = activeTarget[i3+1]||0, tz = activeTarget[i3+2]||0;
                    vx = (tx - px) * 0.14; vy = (ty - py) * 0.14; vz = (tz - pz) * 0.14;
                }

                px += vx; py += vy; pz += vz;
                totalSpeedSq += vx*vx + vy*vy + vz*vz;
                positionsCurrent[i3]=px; positionsCurrent[i3+1]=py; positionsCurrent[i3+2]=pz; posArr[i3]=px; posArr[i3+1]=py; posArr[i3+2]=pz; velocities[i3]=vx; velocities[i3+1]=vy; velocities[i3+2]=vz;
            }

            const avgSpeedSq = totalSpeedSq / P_COUNT; const isStable = avgSpeedSq < 3.0;
            if (activeTargetName !== 'heart' && activeTargetName !== 'torus' && isStable && wasMoving) baseColor.setHSL(Math.random(), 1.0, 0.6);
            wasMoving = !isStable;

            for(let i=0; i<P_COUNT; i++) {
                const i3 = i*3;
                if (activeTargetName === 'heart') {
                     colArr[i3] += (heartColor.r - colArr[i3]) * 0.15; colArr[i3+1] += (heartColor.g - colArr[i3+1]) * 0.15; colArr[i3+2] += (heartColor.b - colArr[i3+2]) * 0.15;
                } else if (activeTargetName === 'torus') {
                     colArr[i3] += (torusColor.r - colArr[i3]) * 0.15; colArr[i3+1] += (torusColor.g - colArr[i3+1]) * 0.15; colArr[i3+2] += (torusColor.b - colArr[i3+2]) * 0.15;
                } else if (!isStable && leftHandAction === 'none') {
                    const hue = (time * 0.5 + i * 0.0008) % 1; tempColor.setHSL(hue, 1.0, 0.7);
                    colArr[i3] += (tempColor.r - colArr[i3]) * 0.3; colArr[i3+1] += (tempColor.g - colArr[i3+1]) * 0.3; colArr[i3+2] += (tempColor.b - colArr[i3+2]) * 0.3;
                } else {
                    colArr[i3] += (baseColor.r - colArr[i3]) * 0.08; colArr[i3+1] += (baseColor.g - colArr[i3+1]) * 0.08; colArr[i3+2] += (baseColor.b - colArr[i3+2]) * 0.08;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true; particles.geometry.attributes.color.needsUpdate = true;
            
            // LOGIC XOAY
            if (leftHandAction === 'none') {
                if (activeTargetName === 'heart') {
                    // N·∫æU L√Ä TIM: T·ª± ƒë·ªông ƒë∆∞a v·ªÅ g√≥c 0 (m·∫∑t ch√≠nh di·ªán) v√† D·ª™NG
                    particles.rotation.y += (0 - particles.rotation.y) * 0.05;
                    particles.rotation.x += (0 - particles.rotation.x) * 0.05;
                } else {
                    // H√¨nh kh√°c th√¨ xoay b√¨nh th∆∞·ªùng
                    particles.rotation.y += 0.003;
                }
                
                if (activeTargetName === 'torus') {
                    particles.rotation.x += 0.002;
                } else if (activeTargetName !== 'heart') {
                    particles.rotation.x *= 0.95; 
                }
            }

            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        setup();
    </script>
</body>
</html>
